[
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "85eacce4-97cb-4f27-b43d-a895e8f66b93",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC001-Login Success with Valid Credentials",
    "description": "Verify that users can log in successfully using valid credentials corresponding to their roles.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Login Failed: Invalid Credentials').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Users could not log in successfully with valid credentials for their roles as expected in the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903595723903//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:42.933Z",
    "modified": "2025-11-23T13:13:15.846Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "1e0bf2b6-217c-4bb3-8cff-7e4c14f2b3c3",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC002-Login Failure with Invalid Credentials",
    "description": "Ensure that users cannot log in with invalid username/email or password and receive appropriate error messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Successful! Welcome back').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Users were able to log in with invalid credentials, but the test plan requires login to fail with an error message indicating invalid credentials.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903599006384//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:42.938Z",
    "modified": "2025-11-23T13:13:19.172Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "b119044e-0b08-4320-9ec0-e828713294d0",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC003-Password Reset via Forgot Password Flow",
    "description": "Validate that users can request password reset and successfully update their password via the forgot password feature.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Password Reset Successful!').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The password reset process did not complete successfully as per the test plan. Expected confirmation message 'Password Reset Successful!' was not found on the page.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903599571608//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:42.944Z",
    "modified": "2025-11-23T13:13:19.749Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "0a9903ef-d821-4471-bc82-03ddb1a61ad0",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC004-Role-Based Route Protection",
    "description": "Ensure that routes and pages are accessible only to authorized user roles according to their permissions.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to navigate to a login page or find any clickable elements or links that might lead to login or authentication.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Input admin username and password, then click Sign In to log in as admin.\n        frame = context.pages[-1]\n        # Input username admin\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        # -> Input password 'admin123' into password field and click Sign In button.\n        frame = context.pages[-1]\n        # Input password admin123\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div/div[3]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to log in as admin\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Close the error dialog and try to retry login or investigate alternative ways to test role-based access without login.\n        frame = context.pages[-1]\n        # Close error dialog\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Retry login by clicking the Sign In button again or try to test access restrictions without login if login continues to fail.\n        frame = context.pages[-1]\n        # Click Sign In button to retry login\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Close the error dialog and explore alternative ways to verify access restrictions, such as checking route guards or permissions in the frontend or backend code, or requesting backend fix.\n        frame = context.pages[-1]\n        # Close error dialog\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to test access restrictions by attempting to access protected routes directly via URL manipulation since login is not working.\n        await page.goto('http://localhost:5173/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to access another protected route /dashboard directly to verify access control.\n        await page.goto('http://localhost:5173/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Attempt to log in again or explore other routes accessible without login to verify role-based access restrictions.\n        frame = context.pages[-1]\n        # Click Login button to attempt login again\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/nav/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Since backend login attempts failed previously, try to test access restrictions by attempting to access other protected routes directly via URL manipulation for different roles or verify frontend route guards.\n        await page.goto('http://localhost:5173/user', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Kolektrash: Waste Collection Made Simple.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=For a Cleaner, Healthier Sipocot').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sign up now').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Bringing together waste collectors and residents for a cleaner Sipocot.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Making waste collection accessible and straightforward for everyone.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Clear communication and easy access to collection schedules and updates.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=We\\'re a dedicated team building smarter waste management solutions for every community.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Ian Jay Anonuevo').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=DEVELOPER').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Passionate about keeping KolekTrash reliable, efficient, and delightful to use.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Emeir Amado').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Angela Olpato').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=MENRO is responsible for overseeing the municipality\\'s waste management operations, ensuring efficient collection, proper disposal, and adherence to environmental standards and policies.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sipocot Office').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=+639457627784').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Monday-Friday | 8am-5pm').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=menro.sipocot@gmail.com').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=We responds within one business day.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=LGU Sipocot Compound').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=South Centro Sipocot, Camarines Sur').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=facebook.com/MENROSipocot').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Monday-Sunday 6AM-6PM').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=© 2025 Municipality of Sipocot – MENRO. All rights reserved.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Responsible waste management').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Environmental stewardship').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Community resilience').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903879659959//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:42.950Z",
    "modified": "2025-11-23T13:17:59.836Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "7fdea736-ddf4-4ee7-beb0-c8b461b9eb1a",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC005-Admin User Management CRUD Operations",
    "description": "Verify that the admin can create, update, and delete users with appropriate roles and that changes reflect in the system.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Find and click login or admin access to proceed to user management.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Click the Login button to proceed to login page.\n        frame = context.pages[-1]\n        # Click the Login button to go to login page\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/nav/div/div/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Login' button at index 7 to navigate to the login page and proceed with admin login.\n        frame = context.pages[-1]\n        # Click the Login button to go to login page\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/nav/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input admin username and password, then click Sign In to log in as admin.\n        frame = context.pages[-1]\n        # Input admin username\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input admin password\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div/div[3]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to log in as admin\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=User creation successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The admin user management test plan execution failed. Unable to verify creation, update, or deletion of users with appropriate roles as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903729669303//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:42.955Z",
    "modified": "2025-11-23T13:15:29.828Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "fb58ca69-6490-4abb-868f-b76d709b3e57",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC006-Route and Schedule Management by Admin",
    "description": "Test that the admin can create, view, update, and delete routes and schedules, and changes are reflected in dependent components.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Route Creation Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The admin was unable to create, view, update, or delete routes and schedules as required by the test plan. Changes are not reflected in dependent components, indicating failure in route and schedule management functionality.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903596654378//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:42.962Z",
    "modified": "2025-11-23T13:13:16.806Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "3ca3a70f-d318-4645-af97-df09ffe791d2",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC007-Task Assignment and Real-Time Updates",
    "description": "Validate that admins and foremen can assign tasks to drivers and collectors and that real-time status updates and notifications are propagated correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Task Assignment Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan to validate task assignments, real-time status updates, and notifications did not pass. 'Task Assignment Successful' message was not found, indicating failure in task assignment or notification propagation.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903600284748//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:42.970Z",
    "modified": "2025-11-23T13:13:20.425Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "bdfddc9d-0cb0-461c-be25-dd16a73f0324",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC008-Special Pickup Request Workflow",
    "description": "Ensure barangay heads and foremen can submit, approve, track special pickup requests with notifications sent on status changes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Special Pickup Request Approved Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The special pickup request approval confirmation message was not found, indicating that the request submission, approval, or notification process did not complete as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903598130617//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:42.975Z",
    "modified": "2025-11-23T13:13:18.287Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "b9bfc29e-7052-46df-a95a-1908687e8586",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC009-Issue Reporting and Tracking",
    "description": "Verify that residents and barangay heads can submit, view, and track reported issues and that status updates propagate correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Issue Resolved Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution failed to verify that residents and barangay heads can submit, view, and track reported issues, and that status updates propagate correctly. The expected status update 'Issue Resolved Successfully' was not found on the page.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903596973915//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:42.982Z",
    "modified": "2025-11-23T13:13:17.101Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "413a1999-66fe-4782-bcfe-de9b72658c1b",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC010-Feedback Submission and Admin Review",
    "description": "Test that residents, barangay heads, and other users can submit feedback and that admins can review feedback submissions.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Feedback Submission Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Feedback submission and review process did not complete successfully as per the test plan. Feedback entries are either not stored or not displayed correctly on the admin dashboard.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903592351648//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:42.988Z",
    "modified": "2025-11-23T13:13:12.524Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "b06073d7-d2e3-46e3-87f7-ee9581e3d3e6",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC011-Notification Delivery and Accuracy",
    "description": "Ensure notifications are sent timely and accurately for task updates, schedule changes, special pickup status, and issue changes to the correct users.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=All notifications delivered successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Notifications were not sent timely and accurately for task updates, schedule changes, special pickup status, and issue changes to the correct users as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903600438343//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:42.994Z",
    "modified": "2025-11-23T13:13:20.633Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "f5d69d89-14f5-44c2-8f7c-f960d1d694a8",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC012-Real-Time Route Tracking and Map Visualization",
    "description": "Validate that truck drivers and garbage collectors can view live routes on maps and task progress updates update the map display in real time.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Route Completed Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The live routes and real-time task progress updates are not displayed correctly on the map as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903593768806//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:43.002Z",
    "modified": "2025-11-23T13:13:13.898Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "1dd56e6e-02ac-4c4d-8ad5-66d5cff36c8b",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC013-Attendance Monitoring for Foremen and Personnel",
    "description": "Test that foremen can record and retrieve attendance records of personnel such as truck drivers and garbage collectors accurately.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Attendance records successfully saved').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Foreman attendance recording and retrieval functionality did not work as expected. Attendance records were not found or could not be retrieved.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903590808898//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:43.008Z",
    "modified": "2025-11-23T13:13:11.023Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "aa867041-09b7-499e-94bf-b1f4cf5bfaa2",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC014-IEC Materials Access and Download",
    "description": "Verify that residents and barangay heads can view and download IEC materials from their portals.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=IEC materials download failed').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Residents and barangay heads could not view or download IEC materials as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/1763903590769376//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:43.014Z",
    "modified": "2025-11-23T13:13:10.907Z"
  },
  {
    "projectId": "18766294-bc0f-4b67-b33e-c283ab929060",
    "testId": "7db6ec2a-666b-41f2-8965-27f29930894d",
    "userId": "b4f8f4f8-2011-70a0-c78c-a17a46404a46",
    "title": "TC015-User Profile and Settings Management",
    "description": "Validate that users can view and update their profiles and account settings across all user roles.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Profile update successful! Your changes have been saved.').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Users could not view or update their profiles and account settings as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b4f8f4f8-2011-70a0-c78c-a17a46404a46/176390358789514//tmp/test_task/result.webm",
    "created": "2025-11-23T13:10:43.019Z",
    "modified": "2025-11-23T13:13:08.019Z"
  }
]
